# Copyright 2017 Gentoo Foundation
# Distributed under the terms of the GNU General Public License v2

from __future__ import print_function

import os
import sys
import time
import shutil
import hashlib
import textwrap
import subprocess

import portage
from portage import _unicode_decode, _unicode_encode
from portage.tests import TestCase
from portage.util import ensure_dirs
from portage.process import find_binary
from portage.const import PORTAGE_PYM_PATH, TIMESTAMP_FORMAT, WORLD_FILE,\
	VDB_PATH, PRIVATE_PATH, CACHE_PATH, MERGING_IDENTIFIER
from portage.tests.resolver.ResolverPlayground import ResolverPlayground

class EmaintTestCase(TestCase):
	"""
	Test emaint commands.
	"""

	def _must_skip(self):
		if find_binary("rsync") is None:
			return "rsync: command not found"

	def testEmaint(self):
		# Change to True to see all the messages generated by the commands.
		debug = False

		skip_reason = self._must_skip()
		if skip_reason:
			self.portage_skip = skip_reason
			self.assertFalse(True, skip_reason)
			return

		repos_conf = textwrap.dedent("""
			[test_repo]
			location = %(EPREFIX)s/var/repositories/test_repo
			sync-type = %(sync-type)s
			sync-uri = file:/%(EPREFIX)s/var/repositories/test_repo_sync
			auto-sync = %(auto-sync)s
		""")

		profile = {
			"eapi": ("5",),
		}

		ebuilds = {
			"dev-libs/A-0": {
				"EAPI" : "5",
				"KEYWORDS" : "x86 x86_64",
			}
		}

		user_config = {}

		playground = ResolverPlayground(ebuilds=ebuilds, profile=profile,
			user_config=user_config, debug=debug)
		settings = playground.settings
		eprefix = settings["EPREFIX"]
		eroot = settings["EROOT"]
		homedir = os.path.join(eroot, "home")
		distdir = os.path.join(eprefix, "distdir")
		repo = settings.repositories["test_repo"]
		# The repo generated by the resolver becomes the sync-uri.
		os.rename(repo.location, repo.location + "_sync")
		metadata_dir = os.path.join(repo.location + "_sync", "metadata")

		for bindir in (self.bindir, self.sbindir):
			path = os.path.join(bindir, "emaint")
			if os.path.exists(path):
				emaint_cmd = (portage._python_interpreter, "-b", "-Wd", path)
				break
		else:
			raise AssertionError("emaint binary not found in %s or %s" %
				(self.bindir, self.sbindir))
		emaint_sync = emaint_cmd + ("sync",)
		emaint_world = emaint_cmd + ("world",)
		emaint_moveinst = emaint_cmd + ("moveinst",)
		emaint_logs = emaint_cmd + ("logs",)
		emaint_cleanconfmem = emaint_cmd + ("cleanconfmem",)
		emaint_cleanresume = emaint_cmd + ("cleanresume",)
		emaint_merges = emaint_cmd + ("merges",)

		emerge_cmd = (portage._python_interpreter, "-b", "-Wd",
			os.path.join(self.bindir, "emerge"))

		print(self.bindir)

		committer_name = "Gentoo Dev"
		committer_email = "gentoo-dev@gentoo.org"

		def repos_set_conf(sync_type, auto_sync="yes"):
			env["PORTAGE_REPOSITORIES"] = repos_conf % {
				"EPREFIX": eprefix,
				"sync-type": sync_type,
				"auto-sync": auto_sync
			}

		sync_tests = (
			{"func" : lambda: repos_set_conf("rsync", auto_sync="no")},
			{"cmd" : emaint_sync + ("--auto",)},
			{"func" : lambda: self.assertNotExists(
				os.path.join(repo.location, "dev-libs", "A"))},
			{"func" : lambda: repos_set_conf("rsync", auto_sync="yes")},
			{"cmd" : emaint_sync + ("--auto",)},
			{"func" : lambda: self.assertExists(
				os.path.join(repo.location, "dev-libs", "A"))},

			{"func" : lambda: print(portage.create_trees())},

			{"func" : lambda: shutil.rmtree(repo.location)},
			{"func" : lambda: repos_set_conf("rsync", auto_sync="no")},
			{"cmd" : emaint_sync + ("--allrepos",)},
			{"func" : lambda: self.assertExists(
				os.path.join(repo.location, "dev-libs", "A"))},
			{"func" : lambda: shutil.rmtree(repo.location)},
			{"cmd" : emaint_sync + ("--repo", "test_repo")},
			{"func" : lambda: self.assertExists(
				os.path.join(repo.location, "dev-libs", "A"))},
			{"cmd" : emaint_sync + ("--repo", "missing_repo"),
				"returncode" : 1},
			{"func" : lambda: repos_set_conf("", auto_sync="yes")},
			{"cmd" : emaint_sync + ("--repo", "test_repo"),
				"returncode": 1},
			{"cmd" : emaint_sync + ("--auto",), "returncode" : 1},
			{"cmd" : emaint_sync + ("--allrepos",), "returncode" : 1},
		)

		def get_file_content(filename):
			content = ""
			with open(filename, "r") as f:
				content = f.read()
			return content.strip()

		def append_file(text, filename):
			with open(filename, "a") as f:
				f.write("%s\n" % (text))

		world_file = os.path.join(eprefix, WORLD_FILE)
		world_tests = (
			{"func" : lambda: repos_set_conf("rsync", auto_sync="yes")},
			{"cmd" : emaint_sync + ("--repo", "test_repo")},
			{"cmd" : emerge_cmd + ("dev-libs/A",)},
			{"func" : lambda: self.assertTrue(
				"dev-libs/A" == get_file_content(world_file))},
			{"cmd" : emaint_world + ("--check",)},
			{"func" : lambda: append_file("dev-libs/invalid", world_file)},
			{"cmd" : emaint_world + ("--check",), "returncode" : 1},
			{"cmd" : emaint_world + ("--fix",)},
			{"cmd" : emaint_world + ("--check",)},
		)

		vdb_dir = os.path.join(eprefix, VDB_PATH)
		updates_dir = os.path.join(repo.location, "profiles", "updates")
		update_file = os.path.join(updates_dir, "1Q-2017")
		moveinst_tests = (
			# Sanity check.
			{"func" : lambda: self.assertExists(
				os.path.join(vdb_dir, "dev-libs", "A-0", "A-0.ebuild"))},
			{"func" : lambda: ensure_dirs(updates_dir)},
			{"cmd" : emaint_moveinst + ("--check",)},
			{"func" : lambda: append_file("move dev-libs/A dev-libs/B", update_file)},
			{"cmd" : emaint_moveinst + ("--check",), "returncode" : 1},
			{"cmd" : emaint_moveinst + ("--fix",)},
			{"func" : lambda: self.assertExists(
				os.path.join(vdb_dir, "dev-libs", "B-0", "B-0.ebuild"))},
			{"cmd" : emaint_moveinst + ("--check",)},
			# Reverting the changes.
			{"func" : lambda: append_file("move dev-libs/B dev-libs/A", update_file)},
			{"cmd" : emaint_moveinst + ("--fix",)},
			# Package was merged during world_tests, unmerging.
			{"cmd" : emerge_cmd + ("--unmerge", "dev-libs/A")},
		)

		def update_logs_mtime():
			files = [f for f in os.listdir(logdir) if f.endswith(".log")]
			for f in files:
				f = os.path.join(logdir, f)
				st = os.stat(f)
				atime = st.st_atime
				mtime = st.st_mtime
				mtime -= 24 * 3600
				os.utime(f, (atime, mtime))

		logdir = os.path.join(eprefix, "var", "log", "portage")
		logs_tests = (
			# Sanity check.
			{"func" : lambda: self.assertTrue(len(os.listdir(logdir)) >= 1)},
			{"func" : lambda: update_logs_mtime()},
			{"cmd" : emaint_logs + ("--check",)},
			{"env_override" : {"PORT_LOGDIR" : ""},
				"cmd" : emaint_logs + ("--check",), "returncode" : 1},
			{"cmd" : emaint_logs + ("--clean",)},
			{"func" : lambda: self.assertTrue(not os.listdir(logdir))},
		)

		config_file = os.path.join(eprefix, PRIVATE_PATH, "config")
		config_entry = "/etc/missing " + \
			(hashlib.md5(_unicode_encode("/etc/missing content")).hexdigest())
		cleanconfmem_tests = (
			{"func" : lambda: append_file(config_entry,config_file)},
			{"cmd" : emaint_cleanconfmem + ("--check",)},
			{"cmd" : emaint_cleanconfmem + ("--fix",)},
			{"func" : lambda: self.assertTrue(not get_file_content(config_file))},
		)

		def add_resume_entry():
			mtimedb = portage.MtimeDB(mtimedb_file)
			mtimedb["resume"] = {
				"favorites" : ["dev-libs/A"],
				"mergelist" : [["ebuild", "/", "dev-libs/A", "merge"]],
				"myopts" : {}
			}
			mtimedb.commit()

		mtimedb_file = os.path.join(eprefix, CACHE_PATH, "mtimedb")
		cleanresume_tests = (
			{"cmd" : emaint_cleanresume + ("--check",)},
			{"func" : lambda: add_resume_entry()},
			{"cmd" : emaint_cleanresume + ("--fix",)},
			{"func" : lambda: self.assertTrue(
				"resume" not in portage.MtimeDB(mtimedb_file))},
		)

		def pkg_installed(pkg):
			trees = portage.create_trees()
			vartree = trees[eroot]["vartree"]
			return vartree.dbapi.match(pkg)

		failed_merges_file = os.path.join(eprefix, PRIVATE_PATH, "failed-merges")
		# emaint merges --fix cannot be tested because it requires user input.
		merges_tests = (
			{"cmd" : emaint_merges + ("--check",)},
			{"func" : lambda: append_file("dev-libs/%sA-0 %d" % \
				(MERGING_IDENTIFIER, int(time.time())), failed_merges_file)},
			{"cmd" : emaint_merges + ("--purge",)},
			{"func" : lambda: self.assertNotExists(failed_merges_file)},
		)

		pythonpath = os.environ.get("PYTHONPATH")
		if pythonpath is None:
			pythonpath = PORTAGE_PYM_PATH
		else:
			pythonpath = pythonpath.strip()
			if not pythonpath:
				pythonpath = PORTAGE_PYM_PATH
			elif pythonpath.split(":")[0] != PORTAGE_PYM_PATH:
				pythonpath = PORTAGE_PYM_PATH + ":" + pythonpath

		env = {
			"PORTAGE_OVERRIDE_EPREFIX" : eprefix,
			"DISTDIR" : distdir,
			"GENTOO_COMMITER_NAME" : committer_name,
			"GENTOO_COMMITER_EMAIL" : committer_email,
			"HOME" : homedir,
			"PATH" : os.environ["PATH"],
			"PORTAGE_GRPNAME" : os.environ["PORTAGE_GRPNAME"],
			"PORTAGE_USERNAME" : os.environ["PORTAGE_USERNAME"],
			"PYTHONDONTWRITEBYTECODE" : os.environ.get("PYTHONDONTWRITEBYTECODE", ""),
			"PYTHONPATH" : pythonpath,
			"PORT_LOGDIR" : logdir,
			"PORT_LOGDIR_CLEAN" : "find ${PORT_LOGDIR} -type f -mtime +0 -delete"
		}
		if os.environ.get("SANDBOX_ON") == "1":
			env["FEATURES"] = "-sandbox -usersandbox"

		dirs = [homedir, metadata_dir]
		try:
			for d in dirs:
				ensure_dirs(d)

			timestamp_path = os.path.join(metadata_dir, "timestamp.chk")
			with open(timestamp_path, "w") as f:
				f.write(time.strftime("%s\n" % TIMESTAMP_FORMAT, time.gmtime()))

			if debug:
				# The subprocess will inherit both stdout and stderr for
				# debugging purposes.
				stdout = None
			else:
				# The subprocess will inherit stderr so that any warning from
				# python -Wd will be visible.
				stdout = subprocess.PIPE

			tests = sync_tests + world_tests + moveinst_tests + logs_tests + \
				cleanconfmem_tests + cleanresume_tests + merges_tests

			for test in tests:
				func = test.get("func", None)
				if func is not None:
					func()
					continue

				cmd = test["cmd"]
				returncode = test.get("returncode", os.EX_OK)
				env_override = test.get("env_override", None)
				if env_override is not None:
					test_env = env.copy()
					test_env.update(env_override)
				else:
					test_env = env

				proc = subprocess.Popen(cmd, cwd=homedir, env=test_env,
					stdout=stdout)
				if debug:
					proc.wait()
				else:
					output = proc.stdout.readlines()
					proc.wait()
					proc.stdout.close()
					if returncode != proc.returncode:
						for line in output:
							print(_unicode_decode(line), file=sys.stderr)

				self.assertEqual(returncode, proc.returncode, "%s failed" %
					(cmd,))
		finally:
			playground.cleanup()
